#!/bin/sh
# Post-push CI watch trigger via reference-transaction hook
# Git doesn't have a native post-push hook, so we detect successful pushes
# by watching for tracking ref updates (refs/remotes/origin/...)
#
# This hook is called with: prepared, committed, or aborted
# We only act on "committed" to run CI watch after successful push

# CI_WATCH_REMOTE: configurable remote name (default: origin)
remote="${CI_WATCH_REMOTE:-origin}"

# Read all stdin first
input=$(cat)

# DEBUG: Uncomment to see invocations
echo "[ref-tx] Phase: $1, input: $input" >&2

# Only process "committed" phase (refs successfully updated)
if [ "$1" != "committed" ]; then
  exit 0
fi

# Find the first tracking ref update and run CI watch
# Using a here-string approach to avoid subshell issues with pipes
found=false
while IFS= read -r line; do
  [ -z "$line" ] && continue

  # Parse: oldvalue newvalue refname (oldvalue unused)
  rest="${line#* }"
  newvalue="${rest%% *}"
  refname="${rest#* }"

  # Match refs/remotes/<remote>/<branch>
  case "$refname" in
    refs/remotes/"$remote"/*)
      found=true
      # Extract branch name (quote $remote separately per SC2295)
      pushed_branch="${refname#refs/remotes/"$remote"/}"
      break
      ;;
  esac
done <<EOF
$input
EOF

# Run CI watch if we found a matching ref
if [ "$found" = true ]; then
  # Use exec to replace this process entirely - avoids any shell cleanup issues
  exec env PUSHED_BRANCH="$pushed_branch" PUSHED_SHA="$newvalue" sh .husky/post-push
fi

# No matching refs found - exit success (normal for prepared/aborted phases)
exit 0
